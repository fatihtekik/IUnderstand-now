import os.path
from ast import get_docstring
import datetime

import telebot
from pyexpat.errors import messages
from telebot import types
import psycopg
from telebot.types import ReplyKeyboardMarkup, ReplyKeyboardRemove

id_teach =None
id_stud = None
user_data2 = {}




token='7576683979:AAF3OwSTLwIA_AAnu0ZVOZUpCk3lIJWsQTQ'
bot=telebot.TeleBot(token)


STUDENT_R = 'student'
TEACHER_R = 'teacher'
login=""

if not os.path.exists('documents'):
    os.makedirs('documents')

#Подключение к БД
def connect_to_db():
    try:
        conn = psycopg.connect(
            dbname = "папапап",
            user = "postgres",
            password = "Aidana2007",
            host = "localhost",
            port = "5432"
        )
        return conn
    except Exception as e:
        print("Ошибка подключения к базе данных.")
        return None

user_data = {}
@bot.message_handler(commands=['start'])
def start_message(message):
  global user_data, id_stud, id_teach, selected_group
  selected_group = {}
  user_data = {}
  id_stud = None
  id_teach = None
  bot.send_message(message.chat.id,"Добро пожаловать в EVALIX, бот по учебной части!\n Введите ваш логин.", reply_markup=ReplyKeyboardRemove())

  user_data[message.chat.id] = {"step": "login"}  # Сохраняем, что находимся на шаге ввода логина


@bot.message_handler(func=lambda message: message.chat.id in user_data and user_data[message.chat.id]["step"] == "login")
def process_login(message):
    global id_stud
    global id_teach
    login = message.text.strip()

    conn = connect_to_db()
    if conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id_student FROM login WHERE login = %s", (login,))
        student = cursor.fetchone()
        print(student)

        cursor.execute("SELECT id_teacher FROM teacher_login WHERE login = %s", (login,))
        teacher = cursor.fetchone()
        print(teacher)

        if student:
            user_data[message.chat.id]["step"] = "password"
            user_data[message.chat.id]["login"] = login
            user_data[message.chat.id]["id_student"] = student[0]
            print(student[0])
            id_stud = student[0]
            user_data[message.chat.id]["role"] = STUDENT_R
            bot.send_message(message.chat.id, "Логин студента найден. Введите ваш пароль.")
        elif teacher:
            user_data[message.chat.id]["step"] = "password"
            user_data[message.chat.id]["login"] = login
            user_data[message.chat.id]["id_teacher"] = teacher[0]
            id_teach=teacher[0]
            print(id_teach)
            user_data[message.chat.id]["role"] = TEACHER_R
            bot.send_message(message.chat.id, "Логин преподавателя найден. Введите ваш пароль.")
        else:
            bot.send_message(message.chat.id, "Такого логина не существует. Попробуйте еще раз.")

        cursor.close()
        conn.close()



@bot.message_handler(
    func=lambda message: message.chat.id in user_data and user_data[message.chat.id]["step"] == "password")
def process_password(message):
    password = message.text.strip()
    login = user_data[message.chat.id].get("login")
    role = user_data[message.chat.id].get("role")

    conn = connect_to_db()
    if conn:
        cursor = conn.cursor()
        if role == STUDENT_R:
            cursor.execute("SELECT password FROM login WHERE login = %s", (login,))
            print(login)
        elif role == TEACHER_R:
            cursor.execute("SELECT password FROM teacher_login WHERE login = %s", (login,))
            print(login)

        user = cursor.fetchone()

        if user and user[0] == password:
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            if role == STUDENT_R:
                markup.add(
                    types.KeyboardButton('Академическая успеваемость'),
                    types.KeyboardButton('оценки и GPA'),
                    types.KeyboardButton('Расписание'),
                    types.KeyboardButton('Рейтинг'),
                    types.KeyboardButton('Документы')
                )
            elif role == TEACHER_R:
                markup.add(
                    types.KeyboardButton('Расписание'),
                    types.KeyboardButton('Переносы'),
                    types.KeyboardButton('Ввод оценок и Н-ок')
                )

            bot.send_message(
                message.chat.id,
                "Пароль верный! Добро пожаловать!",
                reply_markup=markup
            )
            user_data[message.chat.id]["step"] = "authenticated"  # Пользователь аутентифицирован
        else:
            bot.send_message(message.chat.id, "Неверный пароль. Попробуйте еще раз.")

        cursor.close()
        conn.close()
    else:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")




#РАСПИСАНИЕ
stud_schedules = {
    'ПО2301': {
        'ПН': ['ИКТ', 'ИКТ', 'Алгоритмы'],
        'ВТ': ['Алгоритмы', 'БД', 'ИКТ'],
        'СР': ['БД', 'БД', 'Алгоритмы'],
        'ЧТ': ['Алгоритмы', 'Алгоритмы', 'БД'],
        'ПТ': ['БД', 'БД', 'БД']
    },
    'ПО2302': {
        'ПН': ['Алгоритмы', 'Алгоритмы', 'Алгоритмы'],
        'ВТ': ['ИКТ', 'БД', 'БД'],
        'СР': ['БД', 'ИКТ', 'Алгоритмы'],
        'ЧТ': ['БД', 'Алгоритмы', 'БД'],
        'ПТ': ['Алгоритмы', 'БД', 'БД']
    },
    'ВТ2310': {
        'ПН': ['Алгоритмы', 'Алгоритмы', 'БД'],
        'ВТ': ['АК', 'Алгоритмы', 'БД'],
        'СР': ['БД', 'БД', 'Алгоритмы'],
        'ЧТ': ['АК', 'Алгоритмы', 'АК'],
        'ПТ': ['Алгоритмы', 'БД', 'АК']
    }
}

teach_schedules = {
    'ИКТ': {
        'ПН': ['ПО2301', 'ПО2301', ''],
        'ВТ': ['ПО2302', '', 'ПО2302'],
        'СР': [' ', ' ', ' '],
        'ЧТ': [' ', ' ', ' '],
        'ПТ': [' ', ' ', ' ']
    },
    'Составление алгоритмов': {
        'ПН': ['ПО2302', 'ПО2302', 'ПО2301'],
        'ВТ': ['ПО2301', 'ВТ2310', 'ПО2302'],
        'СР': [' ', ' ', 'ПО2302'],
        'ЧТ': ['ПО2301', 'ПО2301', 'ПО2302'],
        'ПТ': ['ПО2302', ' ', '  ']
    },
    'БД': {
        'ПН': [' ', ' ', 'ВТ2310'],
        'ВТ': [' ', 'ПО2301', 'ПО2302'],
        'СР': ['ВТ2310', 'ВТ2310', ' ПО2302'],
        'ЧТ': ['ПО2302', 'ПО2301', 'ПО2301'],
        'ПТ': ['ПО2301', 'ПО2301', 'ПО2301']
   }
}




#Выбор группы
@bot.message_handler(func=lambda message: message.text == 'Расписание')
def choose_group(message):
    role = user_data.get(message.chat.id, {}).get("role", None)
    if role == STUDENT_R:
        markup = types.InlineKeyboardMarkup()
        if "group_id" in user_data[message.chat.id]:
            days = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ']
            buttons = [types.InlineKeyboardButton(day, callback_data=f"day_{day}") for day in days]
            markup.add(*buttons)
            bot.send_message(message.chat.id, f'Вы выбрали группу {user_data[message.chat.id]["group_id"]}. Теперь выберите день недели:',
                         reply_markup=markup)
        else:
            groups = ['ПО2301', 'ПО2302', 'ВТ2310']
            buttons = [types.InlineKeyboardButton(group, callback_data=f"group_{group}") for group in groups]
            markup.add(*buttons)
            bot.send_message(message.chat.id, 'Выберите свою группу:', reply_markup=markup)


    elif role == TEACHER_R:
        markup = types.InlineKeyboardMarkup()
        subjects = ['ИКТ', 'Составление алгоритмов', 'БД']
        buttons = [types.InlineKeyboardButton(subject, callback_data=f"subject_teach_{subject}") for subject in
                   subjects]
        markup.add(*buttons)
        bot.send_message(message.chat.id, 'Выберите предмет для просмотра расписания:', reply_markup=markup)
    else:
        bot.send_message(message.chat.id, "Ваша роль не определена. Обратитесь к администратору.")

# Обработчик выбора группы
@bot.callback_query_handler(func=lambda call: call.data.startswith("group_"))
def choose_day(call):
    role = user_data.get(call.message.chat.id, {}).get("role", None)
    if role == STUDENT_R:
        group_id = call.data.split("_")[1]
        user_data[call.message.chat.id]["group_id"] = group_id
        markup = types.InlineKeyboardMarkup()
        days = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ']
        buttons = [types.InlineKeyboardButton(day, callback_data=f"day_{day}") for day in days]
        markup.add(*buttons)
        bot.send_message(call.message.chat.id, f'Вы выбрали группу {group_id}. Теперь выберите день недели:', reply_markup=markup)

    elif role == TEACHER_R:
        group_id = call.data.split("_")[1]
        user_data[call.message.chat.id]["group_id"] = group_id
        markup = types.InlineKeyboardMarkup()
        days = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ']
        buttons = [types.InlineKeyboardButton(day, callback_data=f"day_{day}") for day in days]
        markup.add(*buttons)
        bot.send_message(call.message.chat.id, f'Вы выбрали группу {group_id}. Теперь выберите день недели:',
                         reply_markup=markup)
    else:
        bot.send_message(call.message.chat.id, "Ваша роль не определена. Пожалуйста, обратитесь к администратору.")

@bot.callback_query_handler(func=lambda call: call.data.startswith("subject_teach_"))
def choose_subject(call):
    subject = call.data.split("_")[2]
    user_data[call.message.chat.id]["subject"] = subject
    markup = types.InlineKeyboardMarkup()
    days = ['ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ']
    buttons = [types.InlineKeyboardButton(day, callback_data=f"day_{day}") for day in days]
    markup.add(*buttons)
    bot.send_message(call.message.chat.id, f'Вы выбрали предмет "{subject}". Теперь выберите день недели:', reply_markup=markup)

# Обработчик выбора дня
@bot.callback_query_handler(func=lambda call: call.data.startswith("day_"))
def show_day_schedule(call):
    role = user_data.get(call.message.chat.id, {}).get("role", None)
    print(role)
    if id_stud is not None:
        day = call.data.split("_")[1]
        group_id = user_data.get(call.message.chat.id)["group_id"]
        if not group_id:
            bot.send_message(call.message.chat.id, "Ошибка: группа не выбрана.")
            return
        if group_id in stud_schedules:
            schedule = stud_schedules[group_id].get(day, [])
            if schedule:
                schedule_text = '\n'.join([f'{i + 1}. {lesson}' for i, lesson in enumerate(schedule)])
                bot.send_message(call.message.chat.id, f'Расписание на {day} для группы {group_id}:\n{schedule_text}')

    elif id_teach is not None:
        day = call.data.split("_")[1]
        subject = user_data.get(call.message.chat.id, {}).get("subject")
        if not subject:
            bot.send_message(call.message.chat.id, "Ошибка: предмет не выбран.")
            return
        if subject in teach_schedules:
            schedule = teach_schedules[subject].get(day, [])
            if schedule:
                schedule_text = '\n'.join([f'{i + 1}. {group}' for i, group in enumerate(schedule) if group.strip()])
                if schedule_text:
                    bot.send_message(call.message.chat.id,
                                     f'Расписание на {day} для предмета {subject}:\n{schedule_text}')
                else:
                    bot.send_message(call.message.chat.id, f'На {day} для предмета {subject} нет занятий.')
            else:
                bot.send_message(call.message.chat.id, f'На {day} для предмета {subject} нет занятий.')
        else:
            bot.send_message(call.message.chat.id, "Расписание для вашего предмета не найдено.")

    else:
        bot.send_message(call.message.chat.id, "Ваша роль не определена. Пожалуйста, обратитесь к администратору.")






def get_gpa_from_score(score):
    if 95 <= score <= 100:
        return 4.0
    elif 90 <= score < 94:
        return 3.67
    elif 85 <= score < 89:
        return 3.33
    elif 80 <= score < 84:
        return 3.0
    elif 75 <= score < 79:
        return 2.67
    elif 70 <= score < 74:
        return 2.33
    elif 65 <= score < 69:
        return 2.0
    elif 60 <= score < 64:
        return 1.67
    elif 55 <= score < 59:
        return 1.33
    elif 50 <= score < 54:
        return 1.0
    else:
        return 0.0



@bot.message_handler(func=lambda message: message.text == 'оценки и GPA')
def show_GPA(message):
    global id_stud


#вы забыли найти айдишку и получали ошибку вместо цифры
    conn = connect_to_db()

    if not conn:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
        return

    cursor = conn.cursor()
    print(id_stud)
    cursor.execute(
        '''SELECT teachers.nazvanie_predmeta,  teachers.FIO_teacher, AVG(ocenki.ocenka) as avg_score
           FROM ocenki 
           JOIN students ON students.id_student = ocenki.id_student 
           JOIN teachers ON teachers.id_teacher = ocenki.id_teacher 
           WHERE students.id_student = %s 
           GROUP BY teachers.nazvanie_predmeta, teachers.FIO_teacher''', (id_stud,)
    )

    rows = cursor.fetchall()
    if not rows:
        bot.send_message(message.chat.id, "Нет данных об оценках.")
        cursor.close()
        conn.close()
        return




    count_s = 0
    total_GPA = 0


    result = ""
    for row in rows:
        nazvanie_predmeta, fio_teacher, avg_score = row
        gpa = get_gpa_from_score(avg_score)
        total_GPA+=gpa
        count_s +=1
        result += (f"Предмет: {nazvanie_predmeta}.\nПреподаватель: {fio_teacher}\n"
                   f"Средняя оценка: {avg_score:.2f}\n"
                   f"GPA: {gpa:.2f}\n\n")

    if count_s > 0:
            overall_gpa = total_GPA / count_s
            result += f"Средний GPA по всем предметам: {overall_gpa:.2f}"
    else:
            result += "Нет оценок для расчета среднего GPA."

    bot.send_message(message.chat.id, result)










@bot.message_handler(func=lambda message: message.text == 'Академическая успеваемость')
def akadem(message):
    global id_stud
    conn = connect_to_db()

    if not conn:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
        return

    cursor = conn.cursor()

    cursor.execute(
        '''
            SELECT DISTINCT teachers.nazvanie_predmeta 
            FROM ocenki
            JOIN teachers ON teachers.id_teacher = ocenki.id_teacher
            JOIN students ON students.id_student = ocenki.id_student
            WHERE students.id_student = %s;''', (id_stud,)
    )

    subjects = cursor.fetchall()
    if not subjects:
        bot.send_message(message.chat.id, "Нет данных об оценках.")
        cursor.close()
        conn.close()
        return

    markup = types.InlineKeyboardMarkup()
    buttons = [ types.InlineKeyboardButton(subjects[0], callback_data= f"subject_{subject[0]}") for subject in subjects]
    markup.add(**buttons)
    bot.send_message(message.chat.id, "Выберите предмет для просмотра успеваемости: ", reply_markup=markup)

    cursor.close()
    conn.close()


@bot.callback_query_handler(func = lambda call: call.data.startswith("row_"))
def show_subject_ocenki(call):
        subject = call.data.split("_")[1]
        conn = connect_to_db()

        if not conn:
            bot.send_message(call.message.chat.id, "Ошибка подключения к базе данных.")
            return

        cursor = conn.cursor()

        cursor.execute(
            '''SELECT teachers.nazvanie_predmeta, teachers.fio_teacher, ocenki.ocenka, ocenki.date
               FROM ocenki
               JOIN teachers ON teachers.id_teacher = ocenki.id_teacher
               JOIN students ON students.id_student = ocenki.id_student
               WHERE students.id_student = %s AND teachers.nazvanie_predmeta = %s
               ORDER BY ocenki.date''',
            (id_stud, subject)
        )

        rows = cursor.fetchall()
        if not rows:
            bot.send_message(call.message.chat.id, f"Нет данных об успеваемости по предмету {subject}.")
            cursor.close()
            conn.close()
            return

        result = f" Предмет: *{subject}*\n Преподаватель: *{rows[0][1]}*\nОценки:\n"
        for row in rows:
            ocenka, fio_teacher, date = row[2], row[1], row[3]
            result += f"   - Оценка: {ocenka}, дата: {date}\n"

        bot.send_message(call.message.chat.id, result, parse_mode="Markdown")

        cursor.close()
        conn.close()


@bot.message_handler(func=lambda message: message.text == 'Документы')
def docs(message):
    markup = types.InlineKeyboardMarkup()
    docs_add= types.InlineKeyboardButton(text="Загрузить документ", callback_data="docs_add")
    docs_show= types.InlineKeyboardButton(text="Показать документ", callback_data="docs_show")
    markup.add(docs_add, docs_show)

    bot.send_message(message.chat.id,"Выберите действие с документами", reply_markup=markup )


@bot.callback_query_handler(func=lambda call: call.data.startswith("docs_"))
def handle_callback(call):
    docum = None
    global id_stud
    global id_teach
    if call.data == "docs_add":
        bot.send_message(call.message.chat.id,"Отправьте файл вашего документа" )

        @bot.message_handler(content_types=['photo', 'video', 'audio', 'text', 'document', 'sticker'])
        def handle_file(message):
                if message.document:
                    file_info = bot.get_file(message.document.file_id)
                    downloaded_file = bot.download_file(file_info.file_path)
                    save_path = os.path.join(r"C:\Users\Admin\Downloads\python aidana\documents",
                                             message.document.file_name)  # сохраняем файл с его исходным именем
                    with open(save_path, 'wb') as new_file:
                        new_file.write(downloaded_file)
                    file_name = message.document.file_name
                    save_file_db(id_stud, file_name, save_path)
                    bot.reply_to(message, f'Файл {file_name} сохранен.')
                else:
                    bot.send_message(message.chat.id, "Документ должен быть в виде файла")






    elif call.data == "docs_show":
        if id_stud is not None:
            docum = get_docs(id_stud)
        elif id_teach is not None:
            docum = get_docs(id_teach)









        if docum:
            for doc in docum:
                bot.send_message(call.message.chat.id, f"Документ: {doc['file_name']}")
                # Отправляем сам файл
                bot.send_document(call.message.chat.id, open(doc['file_path'], 'rb'))
        else:
            bot.send_message(call.message.chat.id, "Вы не загрузили ни один документ.")

def get_docs(stud):
    conn  = connect_to_db()
    cursor = conn.cursor()
    query = "SELECT file_name, file_path FROM documents WHERE stud = %s"
    cursor.execute(query, (stud,))
    documents = cursor.fetchall()
    document_list = [{'file_name': doc[0], 'file_path': doc[1]} for doc in documents]
    return document_list

    cursor.close()
    conn.close()



def save_file_db(stud, file_name, file_path):
    conn=connect_to_db()
    cursor = conn.cursor()
    try:
        query = "insert into documents (stud, file_name, file_path) values(%s, %s, %s)"
        cursor.execute(query, (stud, file_name, file_path))
        conn.commit()


    finally:
        cursor.close()
        conn.close()




@bot.message_handler(func=lambda message: message.text == 'Рейтинг')
def reiting(message):
    global id_stud
    # вы забыли найти айдишку и получали ошибку вместо цифры
    conn = connect_to_db()

    if not conn:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
        return

    cursor = conn.cursor()

    cursor.execute(
        '''SELECT students.id_student, ocenki.ocenka
           FROM ocenki 
           JOIN students ON students.id_student = ocenki.id_student  
           ORDER BY students.id_student'''
    )

    rows = cursor.fetchall()
    if not rows:
        bot.send_message(message.chat.id, "Нет данных об оценках.")
        cursor.close()
        conn.close()
        return

    # Словарь для хранения оценок студентов
    students_grades = {}

    for row in rows:
        id_student, ocenka = row
        if id_student not in students_grades:
            students_grades[id_student] = {"grades": [], "count_zeros": 0}

        students_grades[id_student]["grades"].append(ocenka)
        if ocenka == 0:
            students_grades[id_student]["count_zeros"] += 1

    # Вычисление среднего балла для каждого студента
    students_avg = []
    for student_id, data in students_grades.items():
        total_grades = sum(data["grades"])
        total_count = len(data["grades"])
        avg_grade = total_grades / total_count if total_count > 0 else 0
        students_avg.append({"id_student": student_id, "avg_grade": avg_grade, "count_zeros": data["count_zeros"]})

    # Сортировка студентов по среднему баллу
    students_avg.sort(key=lambda x: x["avg_grade"], reverse=True)

    # Формируем вывод
    result = ""
    for index, student in enumerate(students_avg):
        rank = index + 1
        avg_grade = student["avg_grade"]
        count_zeros = student["count_zeros"]
        result += f"Место: {rank}.\nСредний балл: {avg_grade:.2f}.   Н-ок: {count_zeros}\n\n"

    # Находим место текущего студента
    user_rank = next((index + 1 for index, student in enumerate(students_avg) if student["id_student"] == id_stud),None)

    if user_rank:
        result += f"\nВаше место: {user_rank}.\nСредний балл: {students_avg[user_rank - 1]['avg_grade']:.2f} (с учетом Н-ок).\n"
    else:
        result += "\nНе удалось найти ваше место в рейтинге."

    bot.send_message(message.chat.id, result)





    cursor.close()
    conn.close()

@bot.message_handler(func=lambda message: message.text == 'Переносы')
def vvod(message):
    global id_stud
    global id_teach
    if id_stud is not None:
        bot.send_message(message.chat.id, "Этой функцией могут пользоваться только учителя.")
    elif id_teach is not None:
        conn = connect_to_db()
        if not conn:
            bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
            return

        cursor = conn.cursor()

        cursor.execute(
            '''
            select gruppy.nazvanie_gruppy from gruppy
            join spec_teacher on spec_teacher.spec_id = gruppy.spec_id
            where spec_teacher.teacher_id = %s
            ''', (id_teach,)
        )
        rows = cursor.fetchall()
        if not rows:
            bot.send_message(message.chat.id, "Нет данных о группах.")
            cursor.close()
            conn.close()
            return

        markup = types.InlineKeyboardMarkup()
        for row in rows:
            nazvanie_gruppy = row[0]  # Извлекаем название группы из строки
            print(nazvanie_gruppy)
            button = types.InlineKeyboardButton(text=nazvanie_gruppy, callback_data=f"perenos_{nazvanie_gruppy}")
            markup.add(button)


        bot.send_message(message.chat.id, "Выберите группу:", reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data.startswith("perenos_"))
def choose_group_pzh(call):
    print('a')
    bot.answer_callback_query(call.id)
    global user_data2
    group_name = call.data.split("_")[1]
    print(group_name)
    if call.message.chat.id not in user_data2:
        user_data2[call.message.chat.id] = {}
    user_data2[call.message.chat.id]["group_name"] = group_name

    bot.send_message(call.message.chat.id, "Напишите сообщение студентам")

@bot.message_handler(func=lambda message: message.chat.id in user_data2 and "group_name" in user_data2[message.chat.id])
def handle_group_message(message):
    group_name= user_data2[message.chat.id]["group_name"]
    conn = connect_to_db()
    print(group_name)

    cursor = conn.cursor()
    cursor.execute(
        '''
        select id_gruppy from gruppy where nazvanie_gruppy = %s
        ''', (group_name,)
    )
    group_id = cursor.fetchone()
    if group_id:
        group_id = group_id[0]  # Извлекаем id_gruppy из кортежа
    else:
        bot.send_message(message.chat.id, "Группа не найдена в базе данных.")
        return
    print(group_id)

    cursor.execute(
        '''
        select fio_teacher from teachers where id_teacher = %s
        ''', (id_teach,)
    )
    teacher_name = cursor.fetchone()  # Возвращает (fio_teacher,)
    if teacher_name:
        teacher_name = teacher_name[0]  # Извлекаем строку
    else:
        bot.send_message(message.chat.id, "Преподаватель не найден в базе данных.")
        return
    text_message = message.text


    try:
        cursor.execute(
            '''
            INSERT INTO reschedule (id_gruppy, text_message) 
            VALUES (%s, %s)
            ''',
            (group_id, text_message)
        )
        conn.commit()
    except Exception as e:
        bot.send_message(message.chat.id, f"Ошибка записи в базу данных: {e}")
        cursor.close()
        conn.close()
        return

    # Получаем список пользователей (учеников) из этой группы
    try:
        cursor.execute(
            '''
            select chat_id from student_chat_id where id_gruppy = %s
            ''',
            (group_id,)
        )
        students = cursor.fetchall()
    except Exception as e:
        bot.send_message(message.chat.id, f"Ошибка получения списка студентов: {e}")
        cursor.close()
        conn.close()
        return

    cursor.close()
    conn.close()

    # Если нет зарегистрированных учеников
    if not students:
        bot.send_message(message.chat.id, "В этой группе нет зарегистрированных учеников.")
        return

    # Отправляем сообщение каждому ученику
    for student in students:
        student_id = student[0]  # Извлекаем user_id ученика
        try:
            bot.send_message(
                student_id,
                f"{teacher_name} отправил сообщение: {text_message}"
            )
        except Exception as e:
            print(f"Ошибка отправки сообщения пользователю {student_id}: {e}")

    # Уведомляем учителя, что сообщения отправлены
    bot.send_message(message.chat.id, "Сообщение отправлено всем ученикам группы.")






























@bot.message_handler(func=lambda message: message.text == 'Ввод оценок и Н-ок' and user_data.get(message.chat.id, {}).get("role") == TEACHER_R)
def teacher_menu(message):
    if message.chat.id not in user_data:
        user_data[message.chat.id] = {}
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    markup.add(
        types.KeyboardButton('Выставить оценку'),
        types.KeyboardButton('Отметить пропуск'),
        types.KeyboardButton('Назад')
    )
    bot.send_message(message.chat.id, "Выберите действие:", reply_markup=markup)

# Обработка выставления оценки
@bot.message_handler(func=lambda message: message.text == 'Выставить оценку' and user_data.get(message.chat.id, {}).get("role") == TEACHER_R)
def ask_student_for_grade(message):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if message.chat.id not in user_data:
        user_data[message.chat.id] = {}
    # Получаем список студентов из базы данных
    conn = connect_to_db()
    if conn:
        cursor = conn.cursor()
        cursor.execute('''
            SELECT students.id_student, students.fio
            FROM spec_teacher
            JOIN gruppy ON gruppy.spec_id = spec_teacher.spec_id
            JOIN students ON students.id_gruppy = gruppy.id_gruppy
            WHERE spec_teacher.teacher_id = %s
        ''', (id_teach,))

        students = cursor.fetchall()
        cursor.close()
        conn.close()

        if students:
            markup = types.InlineKeyboardMarkup(row_width=1)
            for student in students:
                student_id, fio = student
                button = types.InlineKeyboardButton(text=fio, callback_data=f"select_student_grade_{student_id}")
                markup.add(button)
            bot.send_message(message.chat.id, "Выберите студента из списка:", reply_markup=markup)
            user_data[message.chat.id]["step"] = "selecting_student_for_grade"
        else:
            bot.send_message(message.chat.id, "Список студентов пуст.")
    else:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")

# Обработка выбора студента для оценки
@bot.callback_query_handler(func=lambda call: call.data.startswith("select_student_grade_"))
def receive_student_for_grade(call):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if call.message.chat.id not in user_data:
        user_data[call.message.chat.id] = {}
    student_id = int(call.data.split("_")[-1])
    user_data[call.message.chat.id]["student_id_for_grade"] = student_id
    bot.send_message(call.message.chat.id, "Введите дату в формате ДД.ММ.ГГГГ:")
    user_data[call.message.chat.id]["step"] = "awaiting_grade_date"

@bot.message_handler(func=lambda message: user_data.get(message.chat.id, {}).get("step") == "awaiting_grade_date")
def receive_grade_date(message):
    date_text = message.text.strip()
    try:
        date_obj = datetime.datetime.strptime(date_text, "%d.%m.%Y").date()
        user_data[message.chat.id]["grade_date"] = date_obj
        bot.send_message(message.chat.id, "Введите оценку (от 0 до 100):")
        user_data[message.chat.id]["step"] = "awaiting_grade_value"
    except ValueError:
        bot.send_message(message.chat.id, "Неверный формат даты. Пожалуйста, введите дату в формате ДД.ММ.ГГГГ.")

@bot.message_handler(func=lambda message: user_data.get(message.chat.id, {}).get("step") == "awaiting_grade_value")
def receive_grade_value(message):
    try:
        grade = int(message.text.strip())
        if 0 <= grade <= 100:
            student_id = user_data[message.chat.id]["student_id_for_grade"]
            teacher_id = user_data[message.chat.id].get("id_teacher")
            grade_date = user_data[message.chat.id]["grade_date"]
            conn = connect_to_db()
            if not conn:
                bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
                return
            cursor = conn.cursor()

            # Проверяем, есть ли уже оценка для этого студента на указанную дату
            cursor.execute(
                "SELECT ocenka FROM ocenki WHERE id_student = %s AND id_teacher = %s AND date = %s",
                (student_id, teacher_id, grade_date)
            )
            existing_grade = cursor.fetchone()

            if existing_grade:
                existing_grade_value = existing_grade[0]
                # Используем инлайн-кнопки для подтверждения
                markup = types.InlineKeyboardMarkup(row_width=2)
                markup.add(
                    types.InlineKeyboardButton("Да", callback_data="confirm_update_grade_yes"),
                    types.InlineKeyboardButton("Нет", callback_data="confirm_update_grade_no")
                )
                bot.send_message(
                    message.chat.id,
                    f"У этого студента уже есть оценка на дату {grade_date.strftime('%d.%m.%Y')}: {existing_grade_value}.\nХотите обновить ее?",
                    reply_markup=markup
                )
                user_data[message.chat.id]["step"] = "confirming_update_grade"
                user_data[message.chat.id]["new_grade"] = grade
            else:
                # Вставляем новую оценку
                cursor.execute(
                    "INSERT INTO ocenki (id_student, id_teacher, ocenka, date) VALUES (%s, %s, %s, %s)",
                    (student_id, teacher_id, grade, grade_date)
                )
                conn.commit()
                bot.send_message(message.chat.id, "Оценка успешно сохранена.")
                user_data[message.chat.id]["step"] = "authenticated"

            cursor.close()
            conn.close()
        else:
            bot.send_message(message.chat.id, "Введите корректную оценку от 0 до 100.")
    except ValueError:
        bot.send_message(message.chat.id, "Введите числовое значение для оценки.")

# Обработка подтверждения обновления оценки
@bot.callback_query_handler(func=lambda call: call.data in ["confirm_update_grade_yes", "confirm_update_grade_no"])
def confirm_update_grade(call):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if call.message.chat.id not in user_data:
        user_data[call.message.chat.id] = {}
    if call.data == "confirm_update_grade_yes":
        student_id = user_data[call.message.chat.id]["student_id_for_grade"]
        teacher_id = user_data[call.message.chat.id].get("id_teacher")
        new_grade = user_data[call.message.chat.id]["new_grade"]
        grade_date = user_data[call.message.chat.id]["grade_date"]
        conn = connect_to_db()
        if not conn:
            bot.send_message(call.message.chat.id, "Ошибка подключения к базе данных.")
            return
        cursor = conn.cursor()

        # Обновляем существующую оценку
        cursor.execute(
            "UPDATE ocenki SET ocenka = %s WHERE id_student = %s AND id_teacher = %s AND date = %s",
            (new_grade, student_id, teacher_id, grade_date)
        )
        conn.commit()
        cursor.close()
        conn.close()

        bot.send_message(call.message.chat.id, "Оценка успешно обновлена.")
        user_data[call.message.chat.id]["step"] = "authenticated"
    elif call.data == "confirm_update_grade_no":
        bot.send_message(call.message.chat.id, "Операция отменена. Оценка не была изменена.")
        user_data[call.message.chat.id]["step"] = "authenticated"

# Обработка отметки пропуска (Н-ки)
@bot.message_handler(func=lambda message: message.text == 'Отметить пропуск' and user_data.get(message.chat.id, {}).get("role") == TEACHER_R)
def ask_student_for_absence(message):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if message.chat.id not in user_data:
        user_data[message.chat.id] = {}
    # Получаем список студентов из базы данных
    conn = connect_to_db()
    if conn:
        cursor = conn.cursor()
        cursor.execute('''
            SELECT students.id_student, students.fio
            FROM spec_teacher
            JOIN gruppy ON gruppy.spec_id = spec_teacher.spec_id
            JOIN students ON students.id_gruppy = gruppy.id_gruppy
            WHERE spec_teacher.teacher_id = %s
        ''', (id_teach,))

        students = cursor.fetchall()
        cursor.close()
        conn.close()

        if students:
            markup = types.InlineKeyboardMarkup(row_width=1)
            for student in students:
                student_id, fio = student
                button = types.InlineKeyboardButton(text=fio, callback_data=f"select_student_absence_{student_id}")
                markup.add(button)
            bot.send_message(message.chat.id, "Выберите студента из списка:", reply_markup=markup)
            user_data[message.chat.id]["step"] = "selecting_student_for_absence"
        else:
            bot.send_message(message.chat.id, "Список студентов пуст.")
    else:
        bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")

# Обработка выбора студента для пропуска
@bot.callback_query_handler(func=lambda call: call.data.startswith("select_student_absence_"))
def receive_student_for_absence(call):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if call.message.chat.id not in user_data:
        user_data[call.message.chat.id] = {}
    student_id = int(call.data.split("_")[-1])
    user_data[call.message.chat.id]["student_id_for_absence"] = student_id
    bot.send_message(call.message.chat.id, "Введите дату в формате ДД.ММ.ГГГГ:")
    user_data[call.message.chat.id]["step"] = "awaiting_absence_date"

@bot.message_handler(func=lambda message: user_data.get(message.chat.id, {}).get("step") == "awaiting_absence_date")
def receive_absence_date(message):
    date_text = message.text.strip()
    try:
        date_obj = datetime.datetime.strptime(date_text, "%d.%m.%Y").date()
        user_data[message.chat.id]["absence_date"] = date_obj
        student_id = user_data[message.chat.id]["student_id_for_absence"]
        teacher_id = user_data[message.chat.id].get("id_teacher")
        conn = connect_to_db()
        if not conn:
            bot.send_message(message.chat.id, "Ошибка подключения к базе данных.")
            return
        cursor = conn.cursor()

        # Проверяем, есть ли уже оценка для этого студента на указанную дату
        cursor.execute(
            "SELECT ocenka FROM ocenki WHERE id_student = %s AND id_teacher = %s AND date = %s",
            (student_id, teacher_id, date_obj)
        )
        existing_grade = cursor.fetchone()

        if existing_grade:
            existing_grade_value = existing_grade[0]
            # Используем инлайн-кнопки для подтверждения
            markup = types.InlineKeyboardMarkup(row_width=2)
            markup.add(
                types.InlineKeyboardButton("Да", callback_data="confirm_update_absence_yes"),
                types.InlineKeyboardButton("Нет", callback_data="confirm_update_absence_no")
            )
            bot.send_message(
                message.chat.id,
                f"У этого студента уже есть оценка на дату {date_obj.strftime('%d.%m.%Y')}: {existing_grade_value}.\nХотите обновить ее на Н-ку?",
                reply_markup=markup
            )
            user_data[message.chat.id]["step"] = "confirming_update_absence"
        else:
            # Вставляем Н-ку
            cursor.execute(
                "INSERT INTO ocenki (id_student, id_teacher, ocenka, date) VALUES (%s, %s, %s, %s)",
                (student_id, teacher_id, 0, date_obj)
            )
            conn.commit()
            bot.send_message(message.chat.id, "Пропуск успешно отмечен.")
            user_data[message.chat.id]["step"] = "authenticated"

        cursor.close()
        conn.close()
    except ValueError:
        bot.send_message(message.chat.id, "Неверный формат даты. Пожалуйста, введите дату в формате ДД.ММ.ГГГГ.")

# Обработка подтверждения обновления пропуска
@bot.callback_query_handler(func=lambda call: call.data in ["confirm_update_absence_yes", "confirm_update_absence_no"])
def confirm_update_absence(call):
    # Инициализируем user_data для данного chat.id, если это необходимо
    if call.message.chat.id not in user_data:
        user_data[call.message.chat.id] = {}
    if call.data == "confirm_update_absence_yes":
        student_id = user_data[call.message.chat.id]["student_id_for_absence"]
        teacher_id = user_data[call.message.chat.id].get("id_teacher")
        absence_date = user_data[call.message.chat.id]["absence_date"]
        conn = connect_to_db()
        if not conn:
            bot.send_message(call.message.chat.id, "Ошибка подключения к базе данных.")
            return
        cursor = conn.cursor()

        # Обновляем оценку на Н-ку
        cursor.execute(
            "UPDATE ocenki SET ocenka = %s WHERE id_student = %s AND id_teacher = %s AND date = %s",
            (0, student_id, teacher_id, absence_date)
        )
        conn.commit()
        cursor.close()
        conn.close()

        bot.send_message(call.message.chat.id, "Оценка успешно обновлена на Н-ку.")
        user_data[call.message.chat.id]["step"] = "authenticated"
    elif call.data == "confirm_update_absence_no":
        bot.send_message(call.message.chat.id, "Операция отменена. Оценка не была изменена.")
        user_data[call.message.chat.id]["step"] = "authenticated"

@bot.message_handler(func=lambda message: message.text == 'Назад')
def go_back(message):
    if message.chat.id not in user_data:
        user_data[message.chat.id] = {}
    user_data[message.chat.id]["step"] = "authenticated"
    # Отправляем главное меню в зависимости от роли
    role = user_data[message.chat.id].get("role")
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    if role == STUDENT_R:
        markup.add(
            types.KeyboardButton('Академическая успеваемость'),
            types.KeyboardButton('Оценки и GPA'),
            types.KeyboardButton('Расписание'),
            types.KeyboardButton('Рейтинг'),
            types.KeyboardButton('Документы'),
            types.KeyboardButton('Оплата за учёбу')
        )
    elif role == TEACHER_R:
        markup.add(
            types.KeyboardButton('Расписание'),
            types.KeyboardButton('Переносы'),
            types.KeyboardButton('Ввод оценок и Н-ок')
        )
    else:
        # Если роль не определена, просим пользователя начать заново
        bot.send_message(message.chat.id, "Пожалуйста, введите /start для начала работы с ботом.")
        return
    bot.send_message(message.chat.id, "Вы вернулись в главное меню.", reply_markup=markup)




bot.infinity_polling()
